You're welcome! I'm glad the initial analysis was helpful. That's an excellent idea to leverage SOQL and the Tooling API to automate some of those manual checks. It definitely makes the process more efficient and repeatable.

Here is a table incorporating potential SOQL and Tooling API queries for the checks we previously identified as requiring manual effort or custom reporting.

**SOQL and Tooling API Queries for Optimizer Checks:**

| Optimizer Check Category | Specific Optimizer Check | Standard SOQL Query (for Data/Usage) | Tooling API SOQL Query (for Metadata Config/Counts) |Notes & Interpretation |
| :--------------------------- | :------------------------------------------------------ | :------------------------------------------------------- | :------------------------------------------------------- | :-------------------------------------------------------------------------------------------------------------------------------- |
| **Security & Access** | Custom Profiles with Low Active User Counts | `SELECT Profile.Name, COUNT(Id) UserCount FROM User WHERE IsActive = true AND Profile.IsCustom = true GROUP BY Profile.Name ORDER BY COUNT(Id) ASC` | `SELECT Id, Name FROM Profile WHERE IsCustom = true` (To list custom profiles) | Use SOQL to find low usage. Tooling API lists profiles for cross-referencing or bulk retrieval if needed. |
| | Permission Sets with Low User Counts | `SELECT PermissionSet.Name, COUNT(AssigneeId) AssignmentCount FROM PermissionSetAssignment WHERE PermissionSet.IsCustom = true AND PermissionSet.IsOwnedByProfile = false GROUP BY PermissionSet.Name ORDER BY COUNT(AssigneeId) ASC` | `SELECT Id, Name, IsCustom FROM PermissionSet WHERE IsOwnedByProfile = false` (To list relevant perm sets) | Use SOQL for assignment counts. Tooling API lists sets for deeper inspection. |
| | Public Groups/Queues with Guest Users | `SELECT Group.Name, Group.Type FROM GroupMember WHERE UserOrGroupId IN (SELECT Id FROM User WHERE UserType = 'Guest')` | `SELECT Id, Name, Type FROM Group WHERE Type = 'Queue' OR Type = 'Regular'` (To list groups/queues) | SOQL identifies groups/queues containing the site guest user. Tooling API can list all groups/queues. Requires site guest user ID lookup first. |
| **Maintenance & Cleanup** | Unused Reports | `SELECT Id, Name, LastRunDate FROM Report ORDER BY LastRunDate ASC NULLS FIRST LIMIT 100` | `SELECT Id, DeveloperName FROM Report USING SCOPE 'Everything'` (To list all reports) | SOQL identifies low usage based on run date. Tooling API helps get a full inventory if needed. |
| | Unused Dashboards | `SELECT Id, Title, LastViewedDate, LastRefreshedDate FROM Dashboard ORDER BY LastViewedDate ASC NULLS FIRST, LastRefreshedDate ASC NULLS FIRST LIMIT 100` | `SELECT Id, DeveloperName FROM Dashboard USING SCOPE 'Everything'` (To list all dashboards) | SOQL identifies low usage. Tooling API provides inventory. |
| | Inactive Users | `SELECT Id, Name, LastLoginDate FROM User WHERE IsActive = true ORDER BY LastLoginDate ASC NULLS FIRST LIMIT 100` | N/A (User data is accessed via standard SOQL) | Standard SOQL is the primary tool here. |
| **Configuration & Limits** | Active Validation Rule Count (per Object) | N/A | `SELECT EntityDefinition.QualifiedApiName, COUNT(Id) RuleCount FROM ValidationRule WHERE Active = true GROUP BY EntityDefinition.QualifiedApiName ORDER BY COUNT(Id) DESC` | Tooling API provides counts per object. Review objects with high counts. Optimizer provided counts against limits. |
| | Active Workflow Rule Count (Org-wide) | N/A | `SELECT COUNT() FROM WorkflowRule WHERE Active = true` | Tooling API gives total active count. Workflows are being retired, so focus should be on migration.[1] |
| | Page Layouts per Object | N/A | `SELECT EntityDefinitionId, COUNT(Id) FROM Layout GROUP BY EntityDefinitionId ORDER BY COUNT(Id) DESC` (Counts total layouts per object) | Tooling API can count total layouts per object. Check limits manually in Setup for specific objects. Optimizer provided counts exceeding thresholds.[2] |
| | Record Types per Object | N/A | `SELECT SobjectType, COUNT(Id) RecordTypeCount FROM RecordType GROUP BY SobjectType ORDER BY COUNT(Id) DESC` | Tooling API provides counts per object. Compare against limits. Optimizer provided counts exceeding thresholds.[2] |
| | Multiple Apex Triggers per Object | N/A | `SELECT EntityDefinition.QualifiedApiName, COUNT(Id) TriggerCount FROM ApexTrigger WHERE Status = 'Active' AND NamespacePrefix = null GROUP BY EntityDefinition.QualifiedApiName HAVING COUNT(Id) > 1 ORDER BY COUNT(Id) DESC` | Tooling API identifies objects with more than one active, custom Apex Trigger. This was a direct Optimizer check.[2] |
| **Code & Customization** | API Versions of Apex Classes | N/A | `SELECT Name, ApiVersion FROM ApexClass WHERE NamespacePrefix = null ORDER BY ApiVersion ASC` | Tooling API lists Apex classes and their API versions. Check for classes using very old versions (e.g., below thresholds mentioned in Salesforce release updates [3]). |
| | API Versions of Apex Triggers | N/A | `SELECT Name, ApiVersion FROM ApexTrigger WHERE NamespacePrefix = null ORDER BY ApiVersion ASC` | Tooling API lists Apex triggers and their API versions. Check for old versions. |
| | Formula Fields with JavaScript (Identification) | N/A | `SELECT EntityDefinition.QualifiedApiName, QualifiedApiName, Formula FROM CustomField WHERE DataType = 'Formula' AND Formula != null` (Retrieve all formulas) | Tooling API retrieves formula fields. Requires a second step (programmatic or manual text search) on the retrieved `Formula` text to check for 'SCRIPT' or 'javascript:'. No direct query filter. |
| | S-Controls | N/A | `SELECT Name, Filename FROM Scontrol` | Tooling API lists S-Controls, which are legacy components flagged by Optimizer.[2] |
| **Maintenance & Cleanup** | Unassigned Custom Profiles | `SELECT Profile.Name, COUNT(Id) UserCount FROM User WHERE IsActive = true AND Profile.IsCustom = true GROUP BY Profile.Name HAVING COUNT(Id) = 0` (Indirect - finds custom profiles with 0 active users) | `SELECT Id, Name FROM Profile WHERE IsCustom = true AND Id NOT IN (SELECT ProfileId FROM User WHERE IsActive = true GROUP BY ProfileId)` (Alternative via Tooling if User accessible) | SOQL is generally better for user counts. Can identify profiles with no active users. |
| | Unassigned Permission Sets | `SELECT PermissionSet.Name, COUNT(AssigneeId) AssignmentCount FROM PermissionSetAssignment WHERE PermissionSet.IsCustom = true AND PermissionSet.IsOwnedByProfile = false GROUP BY PermissionSet.Name HAVING COUNT(AssigneeId) = 0` | `SELECT Id, Name FROM PermissionSet WHERE IsCustom = true AND IsOwnedByProfile = false AND Id NOT IN (SELECT PermissionSetId FROM PermissionSetAssignment)` | Both SOQL and Tooling API can identify custom permission sets with zero assignments. |
| | Unassigned Roles | `SELECT Id, Name FROM UserRole WHERE Id NOT IN (SELECT UserRoleId FROM User WHERE UserRoleId!= NULL AND IsActive = true)` | `SELECT Id, Name FROM UserRole WHERE Id NOT IN (SELECT UserRoleId FROM User WHERE IsActive = true AND UserRoleId != null GROUP BY UserRoleId)` | Both can identify roles with no *direct* active user assignments. |
| | Unassigned Page Layouts | N/A | Requires Metadata API or complex Tooling API queries on `ProfileLayout`. No simple query identifies *unused* layouts definitively. | Check `ProfileLayout` assignments via Tooling API/Metadata API, but requires cross-referencing against active profiles. Hard to determine if truly "unassigned" easily. |
| | Unassigned Record Types | N/A | Requires Metadata API or complex Tooling API queries on `ProfileRecordTypeVisibility`. No simple query identifies *unused* record types easily. | Check `ProfileRecordTypeVisibility` assignments. A record type might be active but not assigned to any *active* user's profile. Requires careful checking. |
| **UI & Adoption** | Unsupported/Out-of-Date Browsers | `SELECT Browser, Platform, COUNT(Id) FROM LoginHistory WHERE LoginTime = LAST_N_DAYS:30 GROUP BY Browser, Platform ORDER BY COUNT(Id) DESC` | N/A | SOQL on `LoginHistory` provides browser usage data. Requires external logic/list to identify unsupported versions from the browser string. |
| | Notes and Attachments Related List (vs Files) | `SELECT COUNT(Id) FROM Attachment` (Total legacy attachments) vs `SELECT COUNT(Id) FROM ContentDocument` (Total Files) | N/A | Use SOQL to compare counts. Requires checking Page Layouts manually/via Metadata API to see which related list is actually displayed. |
| | Field Usage (Populated fields) | N/A (Requires deeper analysis) | `SELECT EntityDefinition.QualifiedApiName, QualifiedApiName, LastModifiedDate FROM CustomField ORDER BY LastModifiedDate ASC` (Potential proxy for least recently *modified* fields) | Tooling API can show when a field *definition* was last modified, but not when data *in* the field was last populated. True field usage analysis often needs dedicated tools (like Field Trip - unofficial) or Apex batch jobs. |

**Important Considerations (Reiterated):**

*   **Permissions:** Ensure appropriate permissions ("View All Data", potentially others) are granted.
*   **API Limits:** Monitor API consumption.
*   **Context is Key:** These queries provide raw data. Interpretation is crucial.
*   **Assignment Complexity:** Truly unused layouts/record types require intricate assignment checks, often better handled via Metadata API retrieval and analysis.
*   **SOQL vs. Tooling API:** Data vs. Metadata distinction remains key.

This expanded table should give you a solid set of queries to automate data gathering for many of the areas Optimizer used to cover. Let me know if any specific check needs further clarification!
